#11장 동시성
- 스레드는 여러 활동을 동시에 수행할 수 있게 해준다. But 난이도 Up  
  멀티코어 프로세서의 힘을 제대로 활용하려면 반드시 내 것으로 만들어야 하는 기술   
  동시성 프로그램을 명확하고 정확하게 만들고 잘 문서화하는데 도움이 되는 조언들을 읽어보자.
  
---  
### Item 78. 공유 중인 가변 데이터는 동기화해 사용하라
- synchronized 키워드
    - 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.
    - 기능 1 : 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화
        - 동기화를 제대로 사용하면 일관된 객체의 상태를 유지
    - 기능 2 : 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 
                 수행된 모든 이전 수정의 최종 결과를 보게 해준다.
    
- 동기화는 베타적 실행뿐만 아니라 스레드 사이의 안정적인 통신에 꼭 필요
  자바는 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된' 값을 얻는다고 보장하지만,
  한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.
  
  - Thread.stop 메서드는 안전하지 않아 사용자제(deprecated) API로 지정되어 있다.
    → 사용하지 말자!
        
        ```java
        //원래 코드
        while(!stopRequested)
        	i++;
        
        //동기화가 빠진 상태에서 JVM이 다음과 같이 최적화를 수행하여 영원히 돌아가는ㄷ...
        //OpenJDK 서버 VM이 실제로 적용하는 hosting 최적화기법이라고 한다.
        if(!stopRequested)
        	while(true)
        		i++;
        
        //해결
        //1. 적절히 동기화하도록 수정한다면 쓰기, 읽기 메서드 추가
        private static synchronized void requestStop(){
        	stopRequested = true;
        }
        
        private static synchronized void stopRequested(){
        	return stopRequested;
        }
        
        //2. volatile 한정자 선언을 통해 가장 최근에 기록된 값을 읽게됨을 보장한다.
        //(주의가 필요하다.)
        private static volatile boolean stopRequested;
        
        //3. java.util.concurrent.atomic을 이용한 락-프리 동기화
        private static final AtomicLong nextSerialNum = new AtomicLong();
        
        public static long generateSerialNumber(){
        	return nextSerialNum.getAndIncrement();
        }
        ```
        
    - 가변데이터는 단일 스레드에서만 쓰자.
    
- 핵심정리
    여러 스레드가 가변데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야한다.
    동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수도 있다.
    공유되는 가변데이터를 동기화하는데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
    이는 디버깅 난이도가 가장 높은 문제에 속한다.
    간헐적이거나 특정 타이밍에만 발생할 수도 있고, VM에 따라 현상이 달라지기도 한다.
    배타적 실행은 필요 없고 스레드끼리의 통신만 필요하다면 volatile 한정자만으로 동기화할 수 있다. 다만 올바로 사용하기가 까다롭다.
    
---
### Item 79. 과도한 동기화는 피하라
- 응답불가와 안전실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.
    - 응답 불가(liveness failure) : 계속 수행되어 응답하지 X
    - 안전 실패(safety failure) : 프로그램이 잘못된 결과를 계산해내는 오류
    
- 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.

- 핵심정리
    교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 
    일반화해 이야기하면, 동기화 영역 안에서의 작업은 최소한으로 줄이자. 
    가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자. 
    멀티코어 세상인 지금은 과도한 동기화를 피하는 게 과거 어느 때보다 중요하다. 
    합당한 이유가 있을 때만 내부에서 동기화하고, 동기화했는지 여부를 문서에 명확히 밝히자(Item 82)
    
---
### Item 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
- java.util.concurrent 패키지, 실행자 서비스
    - 실행자 프레임워크(Executor Framework) : 인터페이스 기반의 유연한 태스크 실행 기능
        - 실행자 서비스의 기능들
        - 특정 태스크가 완료되기를 기다린다.
        - 태스크 모음 중 아무것하나(invokeAny 메서드) 혹은 모든 태스크(invokeAll 메서드)가 완료되기를 기다린다.
        - 실행자 서비스가 종료하기를 기다린다.(awaitTermination 메서드)
        - 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용)
        - 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.(ScheduledThreadPoolExecutor 이용)
        
- 작업 큐를 손수 만드는 일은 삼가해야 하고, 스레드를 직접 다루는 것도 일반적으로 삼가해야한다.
    스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.
    반면 실행자 프레임워크에서는 작업 단위와 수행 메커니즘이 분리된다.
    - 작업단위 : Task
    - 수행 메커니즘 : 실행자 서비스
    자바 7이 되면서 실행자 프레임워크는 포크-조인(fork-join) 태스크를 지원하도록 확장

---
### Item 81. wait와 notify보다는 동시성 유틸리티를 애용하라
- 핵심정리
    wait와 notify를 직접 사용하는 것을 동시성 '어셈블리 언어'로 프로그래밍하는 것에 비유할 수 있다. 
    반면 java.util.concurrent는 고수준 언어에 비유할 수 있다. 코드를 새로 작성한다면 wait와 notify를 쓸 이유가 거의(어쩌면 전혀) 없다. 
    이들을 사용하는 레거시 코드를 유지보수해야 한다면 wait는 항상 표준 관용구에 따라 while 문 안에서 호출하도록 하자. 
    일반적으로 notify보다는 notifyAll을 사용해야 한다. 혹시라도 notify를 사용한다면 응답 불가 상태에 빠지지 않도록 각별히 주의하자.

---
### Item 82. 스레드 안전성 수준을 문서화하라
- 핵심정리
    모든 클래스가 자신의 스레드 안정성 정보를 명확히 문서화 해야한다. 
    정확한 언어로 명확히 설명하거나 스레드 안전성 애너테이션을 사용할 수 있다. 
    synchronized 한정자는 문서화와 관련이 없다. 
    조건부 스레드 안전 클래스는 메서드를 어떤 순서로 호출할 때 외부 동기화가 요구되고, 그때 어떤 락을 얻어야 하는지도 알려줘야 한다. 
    무조건적 스레드 안전 클래스를 작성할 때는 synchronized 메서드가 아닌 비공개 락 객체를 사용하자. 
    이렇게 해야 클라이언트나 하위 클래스에서 동기화 메커니즘을 깨뜨리는 걸 예방할 수 있고, 
    필요하다면 다음에 더 정교한 동시성을 제어 메커니즘으로 재구현할 여지가 생긴다.

---
### Item 83. 지연 초기화는 신중히 사용하라
- 핵심정리
    대부분의 필드는 지연시키지 말고 곧바로 초기화해야 한다. 
    성능 때문에 혹은 위험한 초기화 순환을 막기 위해 꼭 지연 초기화를 써야 한다면 올바른 지연 초기화 기법을 사용하자. 
    인스턴스 필드에는 이중검사 관용구를, 정적 필드에는 지연 초기화 홀더 클래스 관용구를 사용하자. 
    반복해 초기화해도 괜찮은 인스턴스 필드에는 단일검사 관용구도 고려 대상이다.

---
### Item 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
- 핵심정리
    견고성과 이식성을 모두 해치는 행위다. 같은 이유로 Thread.yield와 스레드 우선순위에 의존해서도 안된다. 
    이 기능들은 스레드 스케줄러에 제공하는 힌트일 뿐이다. 
    스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수는 있지만, 
    간신히 동작하는 프로그램을 '고치는 용도'로 사용해서는 절대 안된다.