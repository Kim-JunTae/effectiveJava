# 5장 제네릭
- 제네릭(Generic)은 자바 5부터 사용할 수 있다. 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했다.

- 반면 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다.   
  그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어준다.

- 이번 장에서는 제네릭의 이점을 최대로 살리고 단점을 최소화하는 방법을 이야기한다.

---
### Item26.로 타입은 사용하지 말라
- 제네릭 클래스 or 제네릭 인터페이스 : 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰임

- 매개변수화 타입 : 먼저 클래스(혹인 인터페이스) 이름이 나오고, 이어서 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다.
                 ex) List<String>, String이 정규(formal) 타입 매개변수 E에 해당하는 실제(actual) 타입 매개변수
                 
- 로타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. List<E>의 로타입은 List

- 로타입을 사용하게 된다면 런타임에 오류를 발견하게 되므로 사용하지 말자.   
  로타입을 쓰면 제네릭이 안겨주는 안정성(컴파일시 오류 발견)과 표현력(어떤 타입매개변수를 사용하는지)을 모두 잃게 된다.

- 핵심정리
    - 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안된다. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
      빠르게 훑어보자면, Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고,   
      Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다. 그리고 이들의 로 타입인 Set은 제네릭 타입 시스템에 속하지 않는다.
      Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.
      
---
### Item27.비 검사 경고를 제거하라

- 핵심정리
    - 비검사 경고는 중요하니 무시하지 말자. 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해 제거하라.
      경고를 없앨 방법을 찾이 못하겠다면, 그 코드가 타입 안전함을 증명하고 가능한 범위를 좁혀 @SuppressWarnings("unchecked") 애너테이션으로 경고를 숨겨라. 
      그런 다음 경고를 숨기기로 한 근거를 주석으로 남겨라.
---
### Item28.배열보다는 리스트를 사용하라
- 공변 : Sub가 Super의 하위타입이라면 배열 Sub[]은 배열 Super[]의 하위타입이 된다. (즉, 함께 변화한다는 뜻이다)

- 불공변 : 서로 다른 타입 Type1, Type2가 있을 때 List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다.

- 핵심정리
    - 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다.
      그 결과 배열은 런타임에는 타입 안전하지만 컴파일 타임에는 그렇지 않다. 제네릭은 반대다.
      그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.
---
### Item29.이왕이면 제네릭 타입으로 만들라

- 핵심정리
    - 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 
      그러나 새로운 타입을 설계할 때는 형 변환 없이도 사용할 수 있도록 하라. 그러게 하려면 제네릭 타입으로 만들어야 할 경우가 많다.
      기존 타입 중 제네릭이었어야 하는게 있다면 제네릭 타입으로 변경하자. 
      기존 클라이언트에는 아무 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다.(아이템26)
---
### Item30.이왕이면 제네릭 메서드로 만들라

- 핵심정리
    - 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다.
      타입과 마찬가지로 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다.
      역시 타입과 마찬가지로, 형변환을 해줘야 하는 기존 메서드는 제네릭하게 만들자. 
      기존 클라이언트는 그대로 둔 채 새로운 사용자의 삶을 훨씬 편하게 만들어 줄 것이다.(아이템26)
---
### Item31.한정적 와일드카드를 사용해 API 유연성을 높이라

- 핵심정리
    - 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 횔씬 유연해진다. 그러니 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다.
      PECS 공식을 기억하자. 즉 생성자(producer)는 extends를 소비자(consumer)는 super를 사용한다. Comparable과 Comparator는 모두 소비자라는 사실도 잊지 말자
---
### Item32.제네릭과 가변인수를 함께 쓸 때는 신중하라

- 핵심정리
    - 가변인수와 제네릭은 궁합이 좋지 않다. 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이 서로 다르기 때문이다.
      제네릭 varargs 매개변수는 타입 안전하지는 않지만, 허용된다. 메서드에 제네릭 (혹은 매개변수화된) varargs 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한다음
      @SafeVarargs 애너테이션을 달아 사용하는 데 불편함이 없게끔 하자.
---
### Item33.타입 안정 이종 컨테이너를 고려하라

- 핵심정리
    - 컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있다.
      하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다.
      타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다.
      또한, 직접 구현한 키 타입도 쓸 수 있다. 예컨대 데이터베이스의 행(컨테이너)을 표현한 DatabaseRow 타입에는
      제네릭 타입인 Column<T>를 키로 사용할 수 있다.