# 7장 람다와 스트림
- 자바 8에서 함수형 인터페이스, 람다, 메서드 참조라는 개념이 추가되면서 함수 객체를 더 쉽게 만들 수 있게 되었다.   
  이와 함께 스트림 API까지 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작했다.   
  이번 장에서는 이 기능들을 효과적으로 사용하는 방법을 알아보겠다.
  
---  
### Item42. 익명 클래스보다는 람다를 사용하라 
- 익명클래스 : 
- 람다 :
- 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자
- 람다는 이름이 없고 문서화도 못한다.   
  따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다. (3줄안에!)
- 람다가 대체할 수 없는 곳 : 추상 클래스의 인스턴스를 만들 때는 익명클래스 사용
- 람다를 직렬화하는 일은 X

- 핵심정리
    - 자바 8, 작은 함수 객체를 구현하는데 적합한 람다 도입. 
    - 익명 클래스는(함수형 인터페이스가 아닌) 타입의 인스터스를 만들 때만 사용

---  
### Item43. 람다보다는 메서드 참조를 사용하라
- 간결함. 메서드 참조가 람다보다 더 간결하게 하는 경우가 많다.
- 매개변수의 수가 늘어날수록 메서드 참조로 제거할 수 잇는 코드양도 늘어난다.
- 메서드 참조의 유형 다섯가지
    - 정적
    - 한정적(인스턴스) : 수신객체(참조 대상 인스턴스)를 특정, 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같다.
    - 비한정적(인스턴스) : 수신객체를 특정하지 않음, 함수 객체를 적용하는 시점에 수신 객체를 알려준다. 주롤 스트림 파이프라인에서의 매핑과 필터 함수에 쓰인다.(item45)
    - 클래스 생성자
    - 배열 생성자

- 핵심정리
    - 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.
    
- 람다로는 불가능하나 메서드 참조로는 가능한 유일한 예시 : 제네릭 함수 타입 구현

---  
### Item44. 표준 함수형 인터페이스를 사용하라
- java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스(43개)가 있다.(기본형 6개)   
  필요한 용도에 맞는게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.
  
- Operator 인터페이스 : 반환값과 인수의 타입이 같은 함수
    - 인수가 1개인 UnaryOperator
    - 인수가 2개인 Binary Operator
- Predicate 인터페이스 : 인수 하나를 받아 boolean값을 반환하는 함수
- Function 인터페이스 : 반환값과 인수의 타입이 다른 함수
- Supplier 인터페이스 : 인수를 받지 않고 값을 반환(혹은 제공)하는 함수
- Consumer 인터페이스 : 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수

+ 기본 인터페이스는 기본 타입인 int,long,double 용으로 각 3개씩 변형이 생겨난다.(ex intPredicate...)

- 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. -> 박싱된 기본 타입을 넣어 사용하지는 말자.(동작은 하지만 item61:"박싱된 기본 타입 대신 기본 타입을 사용하라"를 위배한다)

- 핵심정리
    - API를 설계할 때 람다도 생각
    - 입력값과 반환값에 함수형 인터페이스 타입을 활용하라.
    - 보통은 표준 함수형 인터페이스를 사용
    - 직접 새로운 함수형 인터페이스를 만들어 쓸때에는 @FunctionalInterface 애너테이션을 사용하라.
    
---  
### Item45. 스트림은 주의해서 사용하라
- 스트림 API : 다량의 데이터 처리작업을 도와준다.
    - 스트림(stream) : 데이터 원소의 유한 혹은 무한 시퀀스
    - 스트림 파이프라인(stream pipeline) :  이 원소들로 수행하는 연산 단계를 표현하는 개념
        - 소스 스트림 -> (중간 연산) -> 종단 연산
        - 지연평가(lazy evaluation) : 종단 연산 호출 시 시작
        - 플루언트 API : 매서드 연쇄 지원, 파이프라인 하나를 구성하는 모든 호출을 연결하여 하나의 표현식으로 완성
        
- 스트림을 과용하면 프로그램을 읽거나 유지보수하기 어려워진다.
        
- char 값들을 처리할 떄는 스트림을 사용하지 않는 것이 좋다.(기본타입인 char용 스트림을 지원하지 않는다. int값을 반환)
- 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가  더 나아 보일 때만 반영하자.

- 핵심정리
    - 스트림과 반복 중 어느 쪽이 더 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라. 

---  
### Item46. 스트림에서는 부작용 없는 함수를 사용하라

- 핵심정리
    - 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다.   
      스트림뿐 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야한다.
      종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야한다.(계산 자체에는 이용하지 말자.)
      스트림을 올바로 사용하려면 수집기를 잘 알아둬야 한다. 가장 중요한 수집기 팩터리는 toList, toSet, toMap, groupingBy, joining이다.
      
---  
### Item47. 반환 타입으로는 스트림보다 컬렉션이 낫다
- 핵심정리
    - 원소 시퀀스를 반환하는 메서드를 작성할 때는
      이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 떠올리고,
      양쪽을 다 만족시키려 노력하자. 컬렉션을 반환할 수 있다면 그렇게 하라.
      반환 전부터 이미 원소들을 컬렉션에 담아 관리하고 있거나 
      컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList 같은 표준 컬렉션에 담아 반환하라.
      
---  
### Item48. 스트림 병렬화는 주의해서 적용하라
- 핵심정리
    - 계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자.
      스트림을 잘못 병렬화하면 프로그램을 오동작하게 하거나 성능을 급격히 떨어뜨린다. 
      병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라.
      그래서 계산도 정확하고 성능도 좋아졌음이 확실해졌을 때, 오직 그럴 때만 병렬화 버전 코드를 운영코드에 반영하라.