#12장 동시성
> 객체 직렬화 : 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘
 
- 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화할 수 있다.
- 이번 장에서는 직렬화의 위험성과 그 위험을 최소화하는 방법을 소개한다.

### Item 85 자바 직렬화의 대안을 찾으라
- 보안문제
- 직렬화의 근본적인 문제
- 가젯 : 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드
- 역직렬화 폭탄 : 역직렬화에 시간이 오래걸리는 짧은 스트림을 
                          역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다.
→ 직렬화를 써야할 이유가 없다.

- 크로스-플랫폼 구조화된 데이터 표현의 선두주자
    - JSON
    - 프로토콜 버퍼
- 레거시 시스템으로 인한 차선책 : 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는다.
- 화이트리스트 방식으로 객체 역직렬화 필터링(java.io.ObjectInputFilter)를 하자
데이터 스트림이 역직렬화되기전에 필터를 설치하는 기능

### Item 86 Serializable을 구현할지는 신중히 결정하라
- Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.
- 직렬화가 클래스 개선을 방해하는 간단한 예
    - serialVersionUID : 고유 식별 번호, 컴파일러가 자동으로 생성 시 대부분의 클래스 멤버들이 고려된다.
    - 버그와 보안 구멍이 생길 위험이 높아진다.(Item 85)
    - 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.
- 상속용으로 설계된 클래스(Item19)는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장해서는 안된다.
- 내부 클래스(Item24)는 직렬화를 구현하지 말아야 한다.

### Item 87 커스텀 직렬화 형태를 고려해보라
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.(이름)
- 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.
- 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 문제점
    - 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
    - 너무 많은 공간을 차지할 수 있다.
    - 시간이 너무 많이 걸릴 수 있다.
    - 스택 오버 플로를 일으킬 수 있다.
- transient 한정자 : 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시
    - 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 생략
- 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.
- 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
    - private static final long serialVersionUID = 무작위로 고른 long값
    - 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬버전UID를 절대 수정하지 말자

### Item 88 readObject 메서드는 방어적으로 작성하라
- 객체를 역직렬화할 때는 클라이언트각 소유해서는 안되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.
- 핵심정리 읽기

### Item 89 인스턴스 수를 통제해야 한다면 readResolve보다는 열거타입을 사용하라
- 핵심정리 읽기

### Item 90 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
- 핵심정리 읽기